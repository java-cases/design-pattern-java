

## 面向对象设计原则概述
- 软件的**可维护性( Maintainability）**和可复用性( Reusability）是两个非常重要的用于衡量软件质量的属性，软件的可维护性是指软件能够被理解、改正、适应及扩展的难易程度，软件的可复用性是指软件能够被重复使用的难易程度。
- 面向对象设计的目标之一在于支持可维护性复用，一方面需要实现设计方案或者源代码的复用，另一方面要确保系统能够易于扩展和修改，具有良好的可维护性。面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则，但并不是强制性的。
- 面向对象设计原则也是后续设计模式学习的基础，每一个设计模式都符合某一个或多个面向对象设计原则，面向对象设计原则是用于评价一个设计模式的使用效果的重要指标之一。通过在软件开发中使用这些原则可以提高软件的可维护性和可复用性，以便设计出兼具良好的可维护性和可复用性的软件系统，实现可维护性复用的目标。

## 7个常用的面向对象设计原则
### 1 单一职责原则（Single Responsibility Principle,sRP) ★★★★☆
> 一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。 

- 单一职责原则的另一种定义方式：就一个类而，应该仅有一个引起它变化的原因。
- 在软件系统中，一个类(大到模块，小到方法)承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，相当于将这些职责合在一起，当其中一个职责变化时可 能会影响其他职责的运作，因此要将这些职责进行分离。将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装同一个类中。
- 单一职责原则是实现高内聚、低耦合的指导方针，需要设计人员发现类的不同职责并将其分离。 

### 2 开闭原则(Open-Clased Principle, OCP) ★★★★★
> 软件实体应当对扩展开放，对修改关闭。 

- 开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。
- 开闭原则就是指软件实体应尽量在不修改原有代码的情况下进行扩展。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。
- 为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。
- 很多设计模式都符合开闭原则，在对每一个模式进行优/缺点评价时都会将开闭原则作为一个重要的评价依据，以判断基于该模式设计的系统是否具备良好的灵活性和可扩展性。

- 符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。 

### 3 里氏代换原则（Liskov Substitution Principle, LSP) ★★★★★
> 所有引用基类的地方必须能透明地使用其子类的对象。

- 里氏代换原则是实现开闭原则的重要方式之一，由于在使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。
- 在运用里氏代换原则时应该将父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，在运行时子类实例替换父类实例。

### 4 依赖倒转原则（Dependence Inversion Principle, DIP) ★★★★★
> 高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。

- 如果说开闭原则是面向对象设计的目标，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。
- 简单来说，依赖倒转原则要求针对接口编程，不要针对实现编程。
- 依赖倒转原则要求在程序代码中传递参数时或在关联关系中尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。
- 在实现依赖倒转原则时需要针对抽象层编程，而将具体类的对象通过依赖注入(Dependence Injection,DI)的方式注入到其他对象中。

依赖于抽象意味着：
- 任何变量都不应该持有一个指向具体类的指针或者引用。
- 任何类都不应该从具体类派生。
- 任何方法都不应该覆写它的任何基类中的已经实现的方法。

### 5 接口隔离原则(Interface Segregation Principle, ISP) ★★☆☆☆
> 客户端不应该依赖那些它不需要的接口。

- 根据接口隔离原则，当一个接口太大时需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。
- 为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端(如子模块或业务逻辑类)所需的方法即可。
- 在使用接口隔离原则时需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中的接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。

### 6 合成复用原则(Composite Reuse Principle.CRP) ★★★★☆
> 优先使用对象组合，而不是通过继承来达到复用的目的。

- 组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。
- 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的某些内部细节对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变。
- 新对象可以调用已有对象的功能，这样做可以使成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低。
- 合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。
- 如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”的关系可以使用继承。“Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的“一种”;而“Has-A”则不同，它表示某一个角色具有某一项责任。

### 7 迪米特法则(Law of Demeter, LoD) ★★★☆☆
> 每一个软件单元对其他单元都只有最少的知识，而且局限于那些与本单元密切相关的软件单元。

- 迪米特法则要求一个软件实体应当尽可能少地与其他实体发生相互作用。
- 如果一个系统符合迪米特法则，那么当其中的某一个模块发生修改时就会尽量少地影响其他模块，扩展会相对容易，应用迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。

## 其他常见原则

除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。

### 1 共同封闭原则（The Common Closure Principle，CCP）
> 一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。

### 2 稳定抽象原则（The Stable Abstractions Principle，SAP）
> 最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。

### 3 稳定依赖原则（The Stable Dependencies Principle，SDP）
> 包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。