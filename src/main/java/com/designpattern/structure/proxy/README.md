## 代理（Proxy）

### Intent

给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。

代理有以下四类：

- 远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。
- 虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，
可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。
- 保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。
- 智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；
当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。

### Class Diagram

- Proxy：代理对象，通常具有如下功能：
1. 实现与具体的目标对象一样的接口，这样就可以使用代理来代替具体的目标对象。
2. 保存一个指向具体目标对象的引用，可以在需要的时候调用具体的目标对象，可以控制对具体目标对象的访问，并可能负责创建和删除它。

- Subject：目标接口，定义代理和具体目标对象的接口，这样就可以在任何使用具体目标对象的地方使用代理对象

- RealSubject：具体的目标对象，真正实现目标接口要求的功能。

### Implementation

#### 1 虚拟代理
模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。

#### 2 静态代理
Java的静态代理有一个较大的缺点，就是如果Subject接口发生变化，那么代理类和具体的目标实现都要变化，不是很灵活。

#### 3 Java的动态代理
动态代理跟静态代理相比，明显的变化是：
- 静态代理实现的时候，在Subject接口上定义很多的方法，代理类里面自然也要实现很多方法；
- 动态代理实现的时候，虽然Subject接口上定义了很多方法，但是动态代理类始终只有一个invoke方法。这样当Subject接口发生变化的时候，动态代理的接口就不需要跟着变化了。

Java的动态代理目前只能代理接口，基本的实现是依靠Java的反射机制和动态生成class的技术，来动态生成被代理的接口的实现对象。

#### 4 Java的Cglib代理
需要引入第三方jar包

### 设计原则

NA

### JDK

- java.lang.reflect.Proxy
- RMI